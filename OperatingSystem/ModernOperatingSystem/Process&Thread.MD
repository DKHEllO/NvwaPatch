# 操作系统

## 操作系统概念

### 进程

进程本质上是**正在的执行的一个程序**，与每个进程相关的是**地址空间**，这是从某个最小值的**存储位置**通常是0到某个最大值**存储位置**的**列表**。在这个地址空间中进程可以读写，该地址空间存放有**可执行程序、程序的数据以及程序的堆栈**。与每个进程相关的还有资源集，通常包括寄存器、打开的文件清单、突出的报警、有关进程清单等。**进程基本上是容纳一个程序所需要所有信息的容器**。

用户启动一个视频编辑程序，指示它按照某个格式转换一个小时的视频，然后离开去浏览网页。同时一个被周期性唤醒、用来检查进来的电子邮件的后台程序开始运行。这样就有了三个活动进程：视频编辑器、检查电子邮件的后台进程、web浏览器。**操作系统周期性的挂起一个进程然后启动运行另一个进程，这可能是由于在过去的一两秒钟内，第一个进程已经使用完分配给它的时间片。**

一个进程暂时被挂起后，在随后的某个时刻里，该进程再次启动时的状态必须与先前暂停时完全相同，这就意味着在挂起时该进程的所有信息都要保存下来。例如与打开文件相关的指向当前位置的指针。**许多操作系统中，与一个进程相关的所有信息，除了该进程自身地址空间的内容以外，均放在操作系统的一张表中，称为进程表，进程表时数组或链表结构，当前存在的每个进程都要占用其中一项。**

一个挂起的进程包括：进程的地址空间、对应的进程表项（包括**寄存器**以及稍后重启动该进程所需要的许多**其他信息**）

与进程管理有关的最关键的系统调用是那些进行**进程创建**和**进程终止**的系统调用。考虑这种情况，一个命令解释器活shell从终端上读命令。用户输入一个命令要求编译一个程序，shell必须先创建一个新进程来执行编译程序。当执行编译的进程结束后，它执行一个系统调用终止自己。

如果进程可以创建一个或多个进程（子进程），这些进程又可以创建子进程，则可以得到进程树。

其它可用的进程系统调用包括：申请更多的内存、释放内存、**等待一个子进程结束**、用另一个程序覆盖程序

想象tcp的重传机制在两个进程上实现，为了保证一条消息的应答不会丢失，发送者要求它所在的操作系统在指定的若干秒后给一个通知，如果尚未收到确认消息就可以重发。

经过一定的时间，操作系统向该进程发送一个**警告信号(alarm signl)**，此信号让该进程暂时挂起，将寄存器的值保存到堆栈，并开始重新发送丢失的信息

系统管理器授权每个进程使用一个给定的**UID（User IDentification）**。**子进程拥有父进程一样的UID**。用户可以是每个组的成员，每个组也有一个GID

### 地址空间

较复杂的操作系统中允许在内存中同时运行多道程序。为了避免他们互相干扰，需要有某种保护机制。虽然这种机制必然是硬件形式的，但是由操作系统掌控。

虚拟内存技术。**操作系统可以把部分地址空间装入主存，部分留在磁盘上，并且在需要时来回交换它们**。本质上操作系统创建了一个**地址空间的抽象**，作为进程可以引用地址的集合。改地址空间与机器的物理内存解耦，可能大于也可能小于该物理空间。

### 文件

在读写文件前，首先要打开文件，检查其访问权限。若权限许可，系统将返回一个小整数，称作**文件描述符**，供后续操作使用。

在UNIX中另一个重要概念是**特殊文件**，提供特殊文件是为了使I/O设备看起来像是文件一般，I/O设备一个可通过系统调用进行读写。有两类特殊文件：**块特殊文件和字符特殊文件**。块特殊文件指那些可由随机存取的块组成的设备如磁盘等。字符特殊文件用于打印机、调制解调器和其他接受或输出字符流的设备。

**管道**是一种虚文件，它可连接两个进程，如果进程A和B希望通过管道对话，他们必须提前设置该管道。

### 系统调用

记住下列事项是有益的。任何单CPU计算机一次只能执行一条命令。如果一个进程正在用户态与运行一个用户程序，兵器需要一个系统调用，比如从文件读数据，那么它必须执行一个系统调用将控制转移到操作系统，操作系统根据参数查找所需要的调用进程。然后执行系统调用，并把控制返回给在系统调用后面跟随的指令，在某种意义上系统调用就像进行一个特殊的过程调用，但是只有系统调用可以进入内核，而过程调用则不能。

read系统调用：

```c
count = read(fd, buffer, nbytes)
```

count中实际返回读出的字节数。这个值和nbytes相同或更小。

![image-20200705115819705](image-20200705115819705.png)

- 1-3：在准备调用这个实际用来进行read系统调用的库过程中，调用程序先把参数压入堆栈。第一个和第三个参数是值调用，第二个参数通过引用传递实际传递的是地址。

- 4：对库过程的调用

- 5：在可能是由汇编语言写成的库过程中，一般吧系统调用的编号放在操作系统所期望的地方比如寄存器中

- 6：执行一个TRAP指令把用户态切换到内核态，并在内核中的一个固定地址执行

  >TRAP指令实际上与过程调用非常类似，他们后面都跟随一个来自远处位置的指令，已经共以后使用的一个保存在栈中的返回地址，即调用前的用户空间的地址。并且TRAP指令不能跳转到任意地址上，根据机器的体系结构，或者跳转到一个单固定地址上。 

- 7：跟随在TRAP指令后的内核代码开始检查系统调用编号，然后分派给正确的系统处理器，这通常通过一张由系统调用编号所引用的、指向系统调用处理器的指针表来完成

- 8：系统调用处理器运行

- 9：一旦系统调用处理器完成其工作，控制可能会跟随TRAP指令后面的指令中返回给用户空间进程，系统调用者可能堵塞调用者，避免它继续执行。例如如果试图读键盘，但是并没有任何键入，那么调用者就必须被堵塞。这种情况下，操作系统会查看是否有其他可以与运行的进程。稍后需要的输入出现时，进程会提醒系统注意，然后步骤9-11会接着进行

- 10：这个过程接着以通常的过程调用返回的方式，返回到用户程序

- 11：为了完成整个工作，用户程序还必须清除堆栈，如同它在进行任何过程调用后一样

![image-20200705151056364](image-20200705151056364.png)

![image-20200705151113854](image-20200705151113854.png)

#### 用于进程管理的系统调用

##### FORK

**fork**是唯一可以在POSIX中创建进程的途径，它创建一个原有进程的精确副本，包括所有的文件描述符、寄存器等内容。**fork之后原有的进程及其副本就分开了**。fork调用返回一个值，在子进程中该值为0，在父进程中等于子进程的**进程标识符**。

考虑shell的情形，从终端读取命令创建一个子进程，等待子进程执行命令，为了等待子进程结束父进程执行**waitpid**系统调用，等待直到子进程终结。在键入一条命令后，shell调用fork创建一个新的进程，通过使用**execve**系统调用可以实现这一点，这个系统调用会**引起整个核心映像被一个文件替代**，该文件由第一个参数给定。

![image-20200711154626610](image-20200711154626610.png)

waitpid第一个参数-1代表等待任何一个老的子进程，第二个参数为statloc所指向的地址是子进程的退出状态

在UNIX中进程将其存储空间划分为三段：正文段(如程序代码)、数据段(如变量)以及堆栈。数据向上增长而堆栈向下增长，夹在中间的是未使用的地址段：

![image-20200711155123056](image-20200711155123056.png)

### 思考问题

1、内核态和用户态有哪些区别？解释在设计操作系统时存在两种不同模式有什么帮助

2、考虑一个有两个CPU的系统，并且每一个CPU有两个线程。假设有三个程序P0、P1、P2，分别以运行5ms、10ms、20ms开始。运行这些程序需要多少时间？假设这三个程序都是100%限于CPU，在运行时无阻塞，并且一旦设定就不改变CPU。

3、在用户进程进行一个系统调用，以读写磁盘文件时，该程序提供指示说明了所需要的文件、要给指向数据缓冲区的指针以及计数。然后控制权交给操作系统，它调用相关的驱动程序。假设驱动程序启动磁盘并且直到中断发生才终止，在磁盘读的情况下，很明显，调用者会被阻塞，因为文件中没用数据。宰相磁盘写时会发生什么情况

4、什么是陷阱指令？在操作系统中解释它的用途

5、在分时系统中为什么需要进程表？

6、对于以下系统调用给出引起失败的条件：fork、exec以及unlink

7、一台计算机有一个四级流水线，每一级都花费相同的时间执行其工作即1ns。这台机器每秒可执行多少指令

8、假设一个计算机系统有高速缓存、内存（RAM）以及磁盘，操作系统用虚拟内存。读取缓存中的一个词需要1ns，RMA需要10us，磁盘需要10ms。如果缓存的命中率为95%，内存是99%（缓存失效时），读取一个词的平均时间是多少？

9、块特殊文件和字符特殊文件的差异是什么？

10、现代操作系统将进程的地址空间从机器物理内存中分离出来。列举这样设计的两个好处

## 进程与线程

进程时操作系统提供的最古老的也是最重要的抽象概念之一。即使使用的CPU只有一个也有支持伪并发的能力，它们将一个单独的CPU变换成多个虚拟的CPU。没有进程的抽象现代计算将不复存在

### 进程

#### 进程模型

在进程模型中计算机中所有可运行的软件，通常也包括操作系统被组织成若干**顺序进程**，简称进程。一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值。从概念上说，每个进程拥有它自己的虚拟CPU，实际的CPU在进程之间来回切换，这种快速的切换称作**多道程序设计**。

![image-20200711161510679](image-20200711161510679.png)

进程和程序之间的区别是很微妙的，但非常重要，用一个比喻可以理解这一点：

> 想象一位计算机科学家为他的女儿制作生日蛋糕，他有做蛋糕的食谱，厨房里有所需要的原料。在这个比喻中，食谱就是程序，计算机科学家是CPU，而原料就是输入数据。进程就是厨师阅读食谱，取来各种原料以及烘焙蛋糕的一系列动作的总和。现在假设计算机科学家的儿子被蜜蜂蛰了，计算机科学家记录下他照着食谱做到哪了然后拿出一本急救手册按照其中的指示处理蛰伤，处理完成后他又回来从离开时的那一步开始做蛋糕。

这里最关键的思想是：**一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，转而为另一个进程服务**

值得注意的是如果一个程序运行了两边，则算作两个进程

#### 进程的创建

4种事件会导致进程的创建：

1、系统初始化

2、正在运行的程序执行了创建进程的系统调用

3、用户请求创建一个新进程

4、一个批处理作业的初始化

停留在后台处理诸如电子邮件、Web页面、新闻、打印之类的活动的进程称为**守护进程**

一个正在运行的进程经常发出系统调用，以便创建一个或多个进程协助其工作。在所要从事的工作可以容易的划分成若干**相关的但是没有相互作用的进程时**，创建新的进程就特别有效果。

fork是唯一一个可以创建新进程的系统调用,这个系统调用会创建一个**与调用进程相同的副本**。在调用了fork之后，这两个进程拥有相同的**内存映像、同样的环境字符串和同样的打开文件**。通常子进程接着执行execve或一个类似的系统调用以修改其内存映像并运行一个新的程序。

进程创建之后，父进程和子进程有各自**不同的地址空间**。如果其中某个进程在其地址空间中修改了一个字，这个修改对其它进程而言是不可见的。

#### 进程的终止

进程种终止的事件

1、正常退出，自愿的

2、出错退出，自愿的

3、严重错误，非自愿的

4、被其他进程杀死，非自愿的

第三个原因主要是一些执行非法指令、引用不存在的内存等错误

#### 进程的层次结构

在UNIX中，进程和它的所有子进程及其后裔共同组成了一个**进程组**。当用户从键盘发出一个信号时，该信号被送给当前与键盘相关的进程组中的所有成员，每个进程可以分别捕获该信号，忽略该信号或者采用默认动作，即该信号被杀死。

#### 进程的状态

进程的三种状态：

1、运行态，该时刻进程实际占用CPU

2、就绪态，可运行，但因为其他进程正在运行而暂时停止

3、阻塞态，除非某种外部事件发生，否则进程不能运行

![image-20200713230121363](image-20200713230121363.png)

转换操作系统发现进程不能运行下去的时候发生转换1，某些系统中进程可以执行一个系统调用进入阻塞态，当一个进程从管道或设备文件读取数据时，如果没有有效的输入，进程会被自动阻塞

转换2和转换3是由进程调度程序引起的，进程调度程序是操作系统的一部分，它的主要工作就是决定应当运行哪个进程、何时运行以及它应该运行多长时间，这是很重要的一点

使用进程模型是我们易于想象系统内部的操作状况

![image-20200713232101730](image-20200713232101730.png)

关于中断处理、启动进程、停止进程的具体细节都隐藏在调度程序中。

#### 进程的实现

为了实现进程模型，操作系统维护着一张表格，即进程表，每个进程占用一个表项，该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开的文件的状态、账号和调度信息以及其它在进程由运行态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样。

![image-20200713232501784](image-20200713232501784.png)

单个cpu如何维持多个顺序进程的，与每一类I/O类关联的是要给称作中断向量的位置，它包含中断服务程序入口地址。假设当一个磁盘中断发生时，用户进程3正在运行，中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入堆栈，计算机随即跳转到中断向量所指示的地址然后就是软件，中断服务例程接管剩下的工作了。

![image-20200713232845940](image-20200713232845940.png)

#### 多道程序计算模型

如果进程用于计算的平均时间是进程在内存中停留时间的20%，即计算的概率为1/5，且内存中同时有5个进程，则CPU一直满负载运行，这个模型的前提时5个进程不会同时等待I/O

从概率的角度来看CPU利用率，假设一个进程等待I/O操作的时间与其停留在内存中的时间的比为P，当内存中有n个进程且都在等待I/O的概率即CPU空转的概率为pn。cpu利用率为1-pn。

![image-20200713233416462](image-20200713233416462.png)

更精确的模型应该用排队论构建，但上述的模型依然是有效的（当进程就绪时，给进程分配CPU，否则让CPU空转）。

假设计算机有8GB内存，操作系统及相关表格占2GB，每个用户程序占2GB，这些内存孕育3个用户程序同时驻留在内存中，若80%的时间用于I/O等待，则CPU的利用率为1-0.8^3，即49%。增加8GB的内存后，从三道程序设计提高到7道程序设计，cpu利用率提高到79%，换言之第二个8GB提高了30%的吞吐。主要是增加了n的大小
