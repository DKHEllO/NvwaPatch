# 操作系统

## 操作系统概念

### 进程

进程本质上是**正在的执行的一个程序**，与每个进程相关的是**地址空间**，这是从某个最小值的**存储位置**通常是0到某个最大值**存储位置**的**列表**。在这个地址空间中进程可以读写，该地址空间存放有**可执行程序、程序的数据以及程序的堆栈**。与每个进程相关的还有资源集，通常包括寄存器、打开的文件清单、突出的报警、有关进程清单等。**进程基本上是容纳一个程序所需要所有信息的容器**。

用户启动一个视频编辑程序，指示它按照某个格式转换一个小时的视频，然后离开去浏览网页。同时一个被周期性唤醒、用来检查进来的电子邮件的后台程序开始运行。这样就有了三个活动进程：视频编辑器、检查电子邮件的后台进程、web浏览器。**操作系统周期性的挂起一个进程然后启动运行另一个进程，这可能是由于在过去的一两秒钟内，第一个进程已经使用完分配给它的时间片。**

一个进程暂时被挂起后，在随后的某个时刻里，该进程再次启动时的状态必须与先前暂停时完全相同，这就意味着在挂起时该进程的所有信息都要保存下来。例如与打开文件相关的指向当前位置的指针。**许多操作系统中，与一个进程相关的所有信息，除了该进程自身地址空间的内容以外，均放在操作系统的一张表中，称为进程表，进程表时数组或链表结构，当前存在的每个进程都要占用其中一项。**

一个挂起的进程包括：进程的地址空间、对应的进程表项（包括**寄存器**以及稍后重启动该进程所需要的许多**其他信息**）

与进程管理有关的最关键的系统调用是那些进行**进程创建**和**进程终止**的系统调用。考虑这种情况，一个命令解释器活shell从终端上读命令。用户输入一个命令要求编译一个程序，shell必须先创建一个新进程来执行编译程序。当执行编译的进程结束后，它执行一个系统调用终止自己。

如果进程可以创建一个或多个进程（子进程），这些进程又可以创建子进程，则可以得到进程树。

其它可用的进程系统调用包括：申请更多的内存、释放内存、**等待一个子进程结束**、用另一个程序覆盖程序

想象tcp的重传机制在两个进程上实现，为了保证一条消息的应答不会丢失，发送者要求它所在的操作系统在指定的若干秒后给一个通知，如果尚未收到确认消息就可以重发。

经过一定的时间，操作系统向该进程发送一个**警告信号(alarm signl)**，此信号让该进程暂时挂起，将寄存器的值保存到堆栈，并开始重新发送丢失的信息

系统管理器授权每个进程使用一个给定的**UID（User IDentification）**。**子进程拥有父进程一样的UID**。用户可以是每个组的成员，每个组也有一个GID

### 地址空间

较复杂的操作系统中允许在内存中同时运行多道程序。为了避免他们互相干扰，需要有某种保护机制。虽然这种机制必然是硬件形式的，但是由操作系统掌控。

虚拟内存技术。**操作系统可以把部分地址空间装入主存，部分留在磁盘上，并且在需要时来回交换它们**。本质上操作系统创建了一个**地址空间的抽象**，作为进程可以引用地址的集合。改地址空间与机器的物理内存解耦，可能大于也可能小于该物理空间。

### 文件

在读写文件前，首先要打开文件，检查其访问权限。若权限许可，系统将返回一个小整数，称作**文件描述符**，供后续操作使用。

在UNIX中另一个重要概念是**特殊文件**，提供特殊文件是为了使I/O设备看起来像是文件一般，I/O设备一个可通过系统调用进行读写。有两类特殊文件：**块特殊文件和字符特殊文件**。块特殊文件指那些可由随机存取的块组成的设备如磁盘等。字符特殊文件用于打印机、调制解调器和其他接受或输出字符流的设备。

**管道**是一种虚文件，它可连接两个进程，如果进程A和B希望通过管道对话，他们必须提前设置该管道。

### 系统调用

记住下列事项是有益的。任何单CPU计算机一次只能执行一条命令。如果一个进程正在用户态与运行一个用户程序，兵器需要一个系统调用，比如从文件读数据，那么它必须执行一个系统调用将控制转移到操作系统，操作系统根据参数查找所需要的调用进程。然后执行系统调用，并把控制返回给在系统调用后面跟随的指令，在某种意义上系统调用就像进行一个特殊的过程调用，但是只有系统调用可以进入内核，而过程调用则不能。

read系统调用：

```c
count = read(fd, buffer, nbytes)
```

count中实际返回读出的字节数。这个值和nbytes相同或更小。

![image-20200705115819705](image-20200705115819705.png)

- 1-3：在准备调用这个实际用来进行read系统调用的库过程中，调用程序先把参数压入堆栈。第一个和第三个参数是值调用，第二个参数通过引用传递实际传递的是地址。

- 4：对库过程的调用

- 5：在可能是由汇编语言写成的库过程中，一般吧系统调用的编号放在操作系统所期望的地方比如寄存器中

- 6：执行一个TRAP指令把用户态切换到内核态，并在内核中的一个固定地址执行

  >TRAP指令实际上与过程调用非常类似，他们后面都跟随一个来自远处位置的指令，已经共以后使用的一个保存在栈中的返回地址，即调用前的用户空间的地址。并且TRAP指令不能跳转到任意地址上，根据机器的体系结构，或者跳转到一个单固定地址上。 

- 7：跟随在TRAP指令后的内核代码开始检查系统调用编号，然后分派给正确的系统处理器，这通常通过一张由系统调用编号所引用的、指向系统调用处理器的指针表来完成

- 8：系统调用处理器运行

- 9：一旦系统调用处理器完成其工作，控制可能会跟随TRAP指令后面的指令中返回给用户空间进程，系统调用者可能堵塞调用者，避免它继续执行。例如如果试图读键盘，但是并没有任何键入，那么调用者就必须被堵塞。这种情况下，操作系统会查看是否有其他可以与运行的进程。稍后需要的输入出现时，进程会提醒系统注意，然后步骤9-11会接着进行

- 10：这个过程接着以通常的过程调用返回的方式，返回到用户程序

- 11：为了完成整个工作，用户程序还必须清除堆栈，如同它在进行任何过程调用后一样

![image-20200705151056364](image-20200705151056364.png)

![image-20200705151113854](image-20200705151113854.png)

#### 用于进程管理的系统调用

##### FORK

**fork**是唯一可以在POSIX中创建进程的途径，它创建一个原有进程的精确副本，包括所有的文件描述符、寄存器等内容。**fork之后原有的进程及其副本就分开了**。fork调用返回一个值，在子进程中该值为0，在父进程中等于子进程的**进程标识符**。

考虑shell的情形，从终端读取命令创建一个子进程，等待子进程执行命令，为了等待子进程结束父进程执行**waitpid**系统调用，等待直到子进程终结。在键入一条命令后，shell调用fork创建一个新的进程，通过使用**execve**系统调用可以实现这一点，这个系统调用会**引起整个核心映像被一个文件替代**，该文件由第一个参数给定。

![image-20200711154626610](image-20200711154626610.png)

waitpid第一个参数-1代表等待任何一个老的子进程，第二个参数为statloc所指向的地址是子进程的退出状态

在UNIX中进程将其存储空间划分为三段：正文段(如程序代码)、数据段(如变量)以及堆栈。数据向上增长而堆栈向下增长，夹在中间的是未使用的地址段：

![image-20200711155123056](image-20200711155123056.png)

### 思考问题

1、内核态和用户态有哪些区别？解释在设计操作系统时存在两种不同模式有什么帮助

2、考虑一个有两个CPU的系统，并且每一个CPU有两个线程。假设有三个程序P0、P1、P2，分别以运行5ms、10ms、20ms开始。运行这些程序需要多少时间？假设这三个程序都是100%限于CPU，在运行时无阻塞，并且一旦设定就不改变CPU。

3、在用户进程进行一个系统调用，以读写磁盘文件时，该程序提供指示说明了所需要的文件、要给指向数据缓冲区的指针以及计数。然后控制权交给操作系统，它调用相关的驱动程序。假设驱动程序启动磁盘并且直到中断发生才终止，在磁盘读的情况下，很明显，调用者会被阻塞，因为文件中没用数据。宰相磁盘写时会发生什么情况

4、什么是陷阱指令？在操作系统中解释它的用途

5、在分时系统中为什么需要进程表？

6、对于以下系统调用给出引起失败的条件：fork、exec以及unlink

7、一台计算机有一个四级流水线，每一级都花费相同的时间执行其工作即1ns。这台机器每秒可执行多少指令

8、假设一个计算机系统有高速缓存、内存（RAM）以及磁盘，操作系统用虚拟内存。读取缓存中的一个词需要1ns，RMA需要10us，磁盘需要10ms。如果缓存的命中率为95%，内存是99%（缓存失效时），读取一个词的平均时间是多少？

9、块特殊文件和字符特殊文件的差异是什么？

10、现代操作系统将进程的地址空间从机器物理内存中分离出来。列举这样设计的两个好处

## 进程与线程

进程时操作系统提供的最古老的也是最重要的抽象概念之一。即使使用的CPU只有一个也有支持伪并发的能力，它们将一个单独的CPU变换成多个虚拟的CPU。没有进程的抽象现代计算将不复存在

### 进程

#### 进程模型

在进程模型中计算机中所有可运行的软件，通常也包括操作系统被组织成若干**顺序进程**，简称进程。一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值。从概念上说，每个进程拥有它自己的虚拟CPU，实际的CPU在进程之间来回切换，这种快速的切换称作**多道程序设计**。

![image-20200711161510679](image-20200711161510679.png)

进程和程序之间的区别是很微妙的，但非常重要，用一个比喻可以理解这一点：

> 想象一位计算机科学家为他的女儿制作生日蛋糕，他有做蛋糕的食谱，厨房里有所需要的原料。在这个比喻中，食谱就是程序，计算机科学家是CPU，而原料就是输入数据。进程就是厨师阅读食谱，取来各种原料以及烘焙蛋糕的一系列动作的总和。现在假设计算机科学家的儿子被蜜蜂蛰了，计算机科学家记录下他照着食谱做到哪了然后拿出一本急救手册按照其中的指示处理蛰伤，处理完成后他又回来从离开时的那一步开始做蛋糕。

这里最关键的思想是：**一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，转而为另一个进程服务**

值得注意的是如果一个程序运行了两边，则算作两个进程

#### 进程的创建

4种事件会导致进程的创建：

1、系统初始化

2、正在运行的程序执行了创建进程的系统调用

3、用户请求创建一个新进程

4、一个批处理作业的初始化

停留在后台处理诸如电子邮件、Web页面、新闻、打印之类的活动的进程称为**守护进程**

一个正在运行的进程经常发出系统调用，以便创建一个或多个进程协助其工作。在所要从事的工作可以容易的划分成若干**相关的但是没有相互作用的进程时**，创建新的进程就特别有效果。

fork是唯一一个可以创建新进程的系统调用,这个系统调用会创建一个**与调用进程相同的副本**。在调用了fork之后，这两个进程拥有相同的**内存映像、同样的环境字符串和同样的打开文件**。通常子进程接着执行execve或一个类似的系统调用以修改其内存映像并运行一个新的程序。

进程创建之后，父进程和子进程有各自**不同的地址空间**。如果其中某个进程在其地址空间中修改了一个字，这个修改对其它进程而言是不可见的。

#### 进程的终止

进程种终止的事件

1、正常退出，自愿的

2、出错退出，自愿的

3、严重错误，非自愿的

4、被其他进程杀死，非自愿的

第三个原因主要是一些执行非法指令、引用不存在的内存等错误

#### 进程的层次结构

在UNIX中，进程和它的所有子进程及其后裔共同组成了一个**进程组**。当用户从键盘发出一个信号时，该信号被送给当前与键盘相关的进程组中的所有成员，每个进程可以分别捕获该信号，忽略该信号或者采用默认动作，即该信号被杀死。

#### 进程的状态

进程的三种状态：

1、运行态，该时刻进程实际占用CPU

2、就绪态，可运行，但因为其他进程正在运行而暂时停止

3、阻塞态，除非某种外部事件发生，否则进程不能运行

![image-20200713230121363](image-20200713230121363.png)

转换操作系统发现进程不能运行下去的时候发生转换1，某些系统中进程可以执行一个系统调用进入阻塞态，当一个进程从管道或设备文件读取数据时，如果没有有效的输入，进程会被自动阻塞

转换2和转换3是由进程调度程序引起的，进程调度程序是操作系统的一部分，它的主要工作就是决定应当运行哪个进程、何时运行以及它应该运行多长时间，这是很重要的一点

使用进程模型是我们易于想象系统内部的操作状况

![image-20200713232101730](image-20200713232101730.png)

关于中断处理、启动进程、停止进程的具体细节都隐藏在调度程序中。

#### 进程的实现

为了实现进程模型，操作系统维护着一张表格，即进程表，每个进程占用一个表项，该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开的文件的状态、账号和调度信息以及其它在进程由运行态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样。

![image-20200713232501784](image-20200713232501784.png)

单个cpu如何维持多个顺序进程的，与每一类I/O类关联的是要给称作中断向量的位置，它包含中断服务程序入口地址。假设当一个磁盘中断发生时，用户进程3正在运行，中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入堆栈，计算机随即跳转到中断向量所指示的地址然后就是软件，中断服务例程接管剩下的工作了。

![image-20200713232845940](image-20200713232845940.png)

#### 多道程序计算模型

如果进程用于计算的平均时间是进程在内存中停留时间的20%，即计算的概率为1/5，且内存中同时有5个进程，则CPU一直满负载运行，这个模型的前提时5个进程不会同时等待I/O

从概率的角度来看CPU利用率，假设一个进程等待I/O操作的时间与其停留在内存中的时间的比为P，当内存中有n个进程且都在等待I/O的概率即CPU空转的概率为pn。cpu利用率为1-pn。

![image-20200713233416462](image-20200713233416462.png)

更精确的模型应该用排队论构建，但上述的模型依然是有效的（当进程就绪时，给进程分配CPU，否则让CPU空转）。

假设计算机有8GB内存，操作系统及相关表格占2GB，每个用户程序占2GB，这些内存孕育3个用户程序同时驻留在内存中，若80%的时间用于I/O等待，则CPU的利用率为1-0.8^3，即49%。增加8GB的内存后，从三道程序设计提高到7道程序设计，cpu利用率提高到79%，换言之第二个8GB提高了30%的吞吐。主要是增加了n的大小
### 线程

在传统操作系统中，每个进程有一个地址空间和一个控制线程。

#### 线程的使用

线程存在的意义是什么？为什么一个进程中还要再有一类进程（线程），线程存在的必要性是什么。

通过将应用程序分解成可以准并行的多个顺序线程，程序设计模型会变得更简单。

- 有了进程模型的抽象，我们可以不必考虑中断，定时器，和上下文切换，而只需考察并行进程。类似的只有在有了多线程概念之后我们才加入了一种新的元素：并行实体拥有了共享同一个地址空间和所有可用数据的能力，而多进程无法共享一个地址空间和数据，这正是多进程模型不具备的。

- 另一个原因是因为线程比进程更轻量级，他比进程更容易创建也更容易撤销。

- 第三个原因涉及性能方面的讨论。若多个线程都是CPU密集型的，那么并不能获得性能上的增强，但是如果存在大量的计算（大量计算的任务单线程和多线程有区别吗？如果多个线程可以运行在不同核上是有区别的）和大量I/O处理拥有多个线程允许这些活动彼此重叠进行，从而加快应用程序的执行速度，在多CPU系统中多线程是有益的

举个例子，一个字处理软件，一个线程与用户交互，另一个在后台进行格式处理，还有一个进行持久化存储，一旦有文字变化交互线程就通知格式化线程对整本书进行处理，同时交互线程继续监控键盘和鼠标。

如果程序是单线程的，那么在备份时来自键盘和鼠标的命令就会被忽略，直到备份工作完成，另一个方法是引入中断驱动模型设计。但是如果使用三个线程，程序设计模型就会变得很简单，很显然三个进程无法做到这件事情，因为三个线程都需要对同一个文件进行操作，多个线程可以共享内存，所以他们可以访问同一个正在编辑的软件。

![image-20200718101740226](image-20200718101740226.png)

##### 多线程web服务器

在多数web站点上，某些页面较其它页面相比有更多的访问。利用这一事实web服务器可以把获得大量访问的页面集合保存在内存中，避免到磁盘去调用这些页面进而改变性能，这样一个页面集合称为高速缓存。一种组织web服务器的方式如图，一个称为分派程序的线程从网络中读入工作请求，分派线程挑选一个空转的工作线程提交该进程，通常是在每个线程所配有的某个专门字中写入一个消息指针。接着分派线程唤醒睡眠的工作线程，将它从阻塞态转为就绪态。

这种模型允许把服务器编写为一个顺序线程的集合。在**分派线程**的程序中包含一个无限循环，该循环用来获得工作请求并且把工作请求派发给**工作线程**。每个工作线程的代码包含一个从分派线程接受请求并且检查Web高速缓存中是否存在所需页面的无限循环。如果存在就将该页面返回客户机，接着该工作线程阻塞，等待一个新的请求，如果没有就从磁盘调入该页面，将该页面返回给客户机，然后该工作线程阻塞等待一个新的请求。

考虑如果没有多线程如何编写web服务器，一种可能的方式，使其像一个线程一样运行。web服务器的主循环获取请求，检查请求，并且在取下一个请求之前完成整个工作，在**等待磁盘操作时服务器就空转**，并且不处理任何到来的请求，结果导致**每秒只有很少的请求被处理**。

第三种情况，如果有可以使用的read系统调用的非阻塞版本，还存在第三种可能的设计。在请求到来时，这个唯一的线程对请求进行考察，如果该请求不能在高速缓存中得到满足那么启动一个非阻塞的磁盘操作。服务器在表格中记录当前请求的状态，然后去处理下一个事件。下一个事件可能是一个新的工作请求或者是磁盘对先前操作的应答。如果是新的工作请求就开始工作，**如果是磁盘的应答就从表格中取出对应信息并处理**，对于非阻塞I/O这种回答多数会以**信号或中断**的方式出现。

每次服务器从为某个请求工作的状态切换到另一个状态时都必须**显式的保存或重新装入相应的计算状态**，事实上我们以一种困难的方式模拟了**线程及其堆栈**。这里每个计算都有一个被保存的状态，存在一个会发生且使得相关状态发生改变的事件集合，我们把这类设计称为**有限状态机**。

多线程使得**顺序进程**的思想得以保留下来，这种顺序进程**阻塞了系统调用，但仍旧实现了并行性。**

![image-20200718104608429](image-20200718104608429.png)

#### 经典的线程模型

进程模型基于两种独立的概念：**资源分组处理与执行**。有时将这两种概念分开会更好，这就引入了线程的概念。

**理解进程的一个角度是，用某种方法把相关的资源集中在一起**。进程有存放程序正文和数据以及其他资源的地址空间。这些资源包括打开的文件，子进程，即将发生的定时器，信号处理程序，账号信息等。把他们放到进程中更容易管理。

另一个概念是进程拥有一个执行的线程，简写为线程，线程有程序计数器，记录接下来要执行哪条命令。线程拥有寄存器，保存线程当前的工作变量。线程还有堆**栈记录执行历史，其中每一帧保存了一个已调用但还没有返回的过程**。**进程用于把资源集中到一起，而线程则是在CPU上被调度执行的实体。**

在同一个进程中并行运行多个线程是对同一台计算机上并行运行多个进程的模拟。前一种情况下多个线程共享同一个地址空间和其它资源，后一种情况下多个进程共享物理内存，磁盘打印机和其它资源

![image-20200718105845677](image-20200718105845677.png)

![image-20200718105929567](image-20200718105929567.png)

线程概念试图实现的是，共享一组资源的多个线程的执行能力，以便这些线程可以为完成某一任务而共同工作。

线程的状态：运行、阻塞、就绪、终止

正在运行的线程拥有CPU并且是活跃的。被阻塞的线程正在等待某个释放它的事件。就绪的线程可以被调度运行。线程间的状态转换和进程是一样的。

每个线程的堆栈有一帧供各个被调用但是还没有从中返回的过程使用。在该栈帧中存放了相应过程的局部变量以及过程调用完成后使用的返回地址，例如如果过程X调用了Y，Y又调用了Z，供X、Y、Z使用的栈帧都会保存在堆栈中。

在某些系统中通过调用一个过程，如thread_join，一个线程可以等待一个线程退出。这个过程阻塞**调用线程**直到那个线程退出。另一个常见的线程调用是thread_yield，它允许线程自动放弃CPU从而让另一个线程运行，这个很重要，因为线程库无法像进程一样利用始终中断强制让出CPU。

线程在某种程度上也引入了一些复杂性。考虑下fork调用。如果父进程有多个线程，子进程也需要有吗？如果不是则子进程可能无法工作，因为该子进程中的线程都是必须的。然而，如果子进程拥有了与父进程一样的多个进程，如果父进程在read调用上阻塞了会发生什么情况？两个线程被阻塞在键盘上？在键入输入两个线程都应该得到输入的副本吗？还是仅有父进程得到该输入的副本？或者仅有子进程得到？类似的问题在进行网络连接时也会出现。